# -*- coding: utf-8 -*-
"""ai_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wUztAR4EdQUL3vkpM3Is-ps0TEocClry
"""

# !pip install langchain openai qdrant-client gradio pandas tiktoken -U langchain-community
import gradio as gr
import pandas as pd
from langchain.document_loaders.csv_loader import CSVLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.vectorstores import Qdrant
from langchain.chains import VectorDBQA
from langchain.llms import OpenAI
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain.chat_models import ChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.schema import AIMessage, HumanMessage

from google.colab import userdata
openai_api_key=userdata.get('openai_api_key')

 qdrant_url=userdata.get('Qdrant')
qdrant_api_key=userdata.get('qdrant_api_key')
openai_api_key=userdata.get('openai_api_key')
# groq_api_key=userdata.get('GROQ_API_KEY')

#csv loader
loader = CSVLoader(file_path='data.csv')
data=loader.load()

#split the documnts
text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
texts = text_splitter.split_documents(data)


#embeding
embeding=OpenAIEmbeddings(openai_api_key=openai_api_key, model="text-embedding-3-small")


#import quantization

from langchain.vectorstores import Qdrant
from qdrant_client import QdrantClient, models

from langchain.vectorstores import Qdrant

#using qudadrant vector database
from qdrant_client import QdrantClient, models
qdrant = Qdrant.from_documents(
            texts,
            embeding,
            url=qdrant_url,
            prefer_grpc=True,
            api_key=qdrant_api_key,
            collection_name="llm_app",
            quantization_config=models.BinaryQuantization(
                binary=models.BinaryQuantizationConfig(
                    always_ram=True,
                )
            )
)


#qdrant client
qdrant_client = QdrantClient(
    url=qdrant_url,
    prefer_grpc=True,
    api_key=qdrant_api_key,
)

from re import search
#retriver
retriver=qdrant.as_retriever( search_type="similarity", search_kwargs={"k":2})


#search query
query="show me a best darmatology doctor in peshawar  "
docs=retriver.get_relevant_documents(query)


from langchain import PromptTemplate

prompt = PromptTemplate(
    template="""
        # Your Role
        You are a highly skilled AI specialized in healthcare and medical information retrieval. Your expertise lies in understanding the medical needs of patients and accurately matching them with the most suitable healthcare professionals, including but not limited to surgeons, dentists, dermatologists, cardiologists, neurologists, etc., based on the user's query and the provided context.

        # Instruction
        Your task is to answer the question using the following pieces of retrieved context delimited by XML tags.

        <retrieved context>
        Retrieved Context:
        {context}
        </retrieved context>

        # Constraint
        1. Carefully analyze the user's question:
        User's question:\n{question}\n
        Your goal is to understand the user's needs and match them with the most relevant healthcare professional(s) from the provided context.
        - Reflect on why the question was asked, and deliver an appropriate response based on the context you understand.
        2. Select the most relevant information (the key details directly related to the question) from the retrieved context and use it to formulate an answer.
        3. Generate a comprehensive, logical, and medically accurate answer. When generating the answer, include the following details about the healthcare professional:
            • Name of the Professional
            • City
            • Specialization (e.g., Surgeon, Dentist, Cardiologist, etc.)
            • Qualification (e.g., MBBS, FCPS, etc.)
            • Years of Experience
            • Patient Satisfaction Rate (if available)
            • Average Time Spent with Patients (if available)
            • Wait Time (if available)
            • Hospital/Clinic Address
            • Consultation Fee
            • Profile Link (if available)
        4. If the retrieved context does not contain enough relevant information, or if the documents are irrelevant, respond with 'I can't find the answer to that question in the material I have'.
        5. Provide a complete answer to the user. Do not limit the information if there is more useful data available in the retrieved context.
        6. At the end of the response, do not include any unnecessary metadata (such as Source, Row, or _id). Only focus on the healthcare professional's information relevant to the user's query.

        # Question:
        {question}""",
    input_variables=["context", "question"]
)


#import ChatOpenAI
# llm = ChatOpenAI(model_name="gpt-4o", temperature=0, openai_api_key=openai_api_key)
llm = ChatOpenAI(temperature=0.5, model='gpt-4o', openai_api_key=openai_api_key)




def format_docs(docs):
        formatted_docs = []
        for doc in docs:
            # Format the metadata into a string
            metadata_str = ', '.join(f"{key}: {value}" for key, value in doc.metadata.items())

            # Combine page content with its metadata
            doc_str = f"{doc.page_content}\nMetadata: {metadata_str}"

            # Append to the list of formatted documents
            formatted_docs.append(doc_str)

        # Join all formatted documents with double newlines
        return "\n\n".join(formatted_docs)

#import strw

        from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnablePassthrough
rag_chain = (
            {"context":  retriver| format_docs, "question": RunnablePassthrough()}
            | prompt
            | llm
            | StrOutputParser()
        )

from langchain.chat_models import ChatOpenAI
from langchain.schema import AIMessage, HumanMessage
import openai
import os
import gradio as gr


def reg(message, history):
    history_langchain_format = []
    for human, ai in history:
        history_langchain_format.append(HumanMessage(content=human))
        history_langchain_format.append(AIMessage(content=ai))
    history_langchain_format.append(HumanMessage(content=message))
    gpt_response = llm(history_langchain_format)
    return rag_chain.invoke(message)
# Gradio ChatInterface
demo = gr.ChatInterface(
    fn=reg,
    title="Doctors Appointments Assistant",
    theme="soft",
)

demo.launch(show_api=False)